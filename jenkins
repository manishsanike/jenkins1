def environmentFileName = ".\\${params.DockerDeploymentFiles}\\image.properties"

pipeline {
    agent {
        label 'master'
    }
    options {
    	buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
    }
    parameters { 
      string(name: 'RepositoryURL', defaultValue: 'https://bitbucket.fis.dev/scm/investran/investraninv.git',  description: 'Bitbucket repository URL.')
      string(name: 'BranchName',  defaultValue: 'development',  description: 'Bitbucket repository branch name.')
      string(name: 'BitBucketCredential',  defaultValue: 'manish-cred',  description: 'Bitbucket repository branch name.')
      string(name: 'DockerDeploymentFiles',  defaultValue: '.\\docker\\InfinityOAT2\\Accounting-WebApi',  description: 'Path of Docker and docker-compose.yaml file')
      string(name: 'ApplicationDir',  defaultValue: 'Accounting-WebApi',  description: 'Application Directory Name')
      credentials(
        credentialType: 'com.cloudbees.jenkins.plugins.sshcredentials.SSHUserPrivateKey',
        defaultValue: 'rundeck',
        description: 'The credentials needed to deploy.',
        name: 'deployCredentialsId',
        required: true
      )

    }                 
    stages {
        stage ('Source Code Checkout') {
            steps {
	      dir ("${WORKSPACE}") {
                cleanWs()
                checkout scm: [$class: 'GitSCM', userRemoteConfigs: [[url: "${params.RepositoryURL}", credentialsId: "${params.BitBucketCredential}"]],
                branches: [[name: "${params.BranchName}"]]], poll: false
                   
                      load "./${environmentFileName}"                    
                }
           }
        }        
	stage('Modify Docker Deployment') {
          steps {
            dir ("${WORKSPACE}") {
            powershell script:
            """
	   (Get-Content -path $params.DockerDeploymentFiles\\docker-compose-base.yml -Raw).replace('\${RepositoryName}', '$env.RepositoryName') | Set-Content -path $params.DockerDeploymentFiles\\docker-compose-base.yml
            (Get-Content -path $params.DockerDeploymentFiles\\docker-compose-base.yml -Raw).replace('\${ImageVersion}', '$env.image_version') | Set-Content -path $params.DockerDeploymentFiles\\docker-compose-base.yml
            cat $params.DockerDeploymentFiles\\docker-compose-base.yml

            """
            }
          }
	}
        stage('Docker Cluster Deployment') {
          steps {
            script {
              def remote = [:]
                  remote.name = "$env.name"
                  remote.host = "$env.hostname"
                  remote.allowAnyHosts = true
              withCredentials([sshUserPrivateKey(credentialsId: '${deployCredentialsId}', 
                        keyFileVariable: 'JENKINS_PRIVATE_KEY', usernameVariable: 'USERNAME')]) {
                 remote.user = USERNAME
                 remote.identityFile = JENKINS_PRIVATE_KEY
            dir ("${WORKSPACE}") {
	    sshCommand remote: remote, command: "mkdir -p /tmp/$env.ApplicationName"
            sshPut remote: remote, from: "${params.DockerDeploymentFiles}", into: "/tmp/$env.ApplicationName/"
	    sshCommand remote: remote, command: "ls -ltrh /tmp/$env.ApplicationName/${params.ApplicationDir}"
            sshCommand remote: remote, command: "cd /tmp/$env.ApplicationName/${params.ApplicationDir}; dos2unix Docker_Deployment.sh; sh Docker_Deployment.sh $env.RepositoryName:$env.image_version $env.ApplicationName"
            sshRemove remote: remote, path: "/tmp/$env.ApplicationName"
              }
            }
          }
        }
      }
    }     
    post { 
        always {
	    sleep 5
            cleanWs()
        }
    }    
  }
